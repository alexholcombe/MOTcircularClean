---
title: "Examine eyetracking data for an individual participant"
format: html
editor: visual
---

Overall the exampleAnalysesWithGoodFixator report from that file showed that for at least 7 trials out of 120, the eyetracker is way off, with X off by 90 pixels. Otherwise, things were reasonable esp. after first 500 ms when fixation period starts. But by reasonable, I mean that drift or something means that X and Y was off by up to \~20 pixels. For the weird 7 trials, there weren't many fixations so I should check how much missing data ("blinks") there was, maybe that helps explain why those trials were weird.

To-do: Add a form of drift correction, like maybe the average starting eye position in every 20 trials.

## Do basic checks

```{r}
#| echo: false
library(eyelinkReader)
library(dplyr)
library(ggplot2)
widthPix = 800; heightPix = 600
```

Read in an EDF file.

```{r}
#| echo: false

directoryWithDataFile<-"dataForTestingOfCode"
fname<-"M471.EDF"
EDFfileWithPath<-file.path(directoryWithDataFile,fname)
if (!file.exists(EDFfileWithPath)) {
  message( paste0("File'",EDFfileWithPath,"'not found!") )
  stop('Could not find the file')
}
EDFstuff <- eyelinkReader::read_edf(EDFfileWithPath,
                                    import_samples = TRUE,
                                    sample_attributes = c('time', 'gx', 'gy'))
```

Check which eye was tracked, and create new x and y columns based on which eye it was.
```{r whichEye}
#| echo: false

samples<- EDFstuff$samples
numNotNArightEye <- sum( !is.na(samples$gxR) )
numNotNAleftEye <- sum( !is.na(samples$gxL) )
if (numNotNArightEye>0 & numNotNAleftEye==0) {
  message("The right eye was tracked exclusively.")
  samples$x <- samples$gxR
  samples$y <- samples$gyR
}
if (numNotNAleftEye>0 & numNotNArightEye==0) {
  message("The left eye was tracked exclusively.")
  samples$x <- samples$gxL
  samples$y <- samples$gyL
}
if (numNotNAleftEye>0 & numNotNArightEye>0) {
  message("Sometimes the left eye was tracked and on others the right, and I'm not set up to handle that. You should check each trial.")
}

```
## Graphs

Assuming screen width is `r widthPix` pixels and screen height is `r heightPix` pixels,

check mean x in and mean y in samples (raw eyetracker record of where person was looking) to see where it is relative to screen center.

```{r}
#| echo: false

screenCtr <-  data.frame( x=widthPix/2, y= heightPix/2)
criterionDist<-40
avgSampleRelCtr<- samples %>%
                summarise(x = mean(x,na.rm=TRUE), y = mean(y,na.rm=TRUE)) - screenCtr

# Function to check for any TRUE values but return FALSE if all are NaN, as will occur if no values because the other eye was tracked or there is no data.
any_true_except_all_nan <- function(x) {
  if (all(is.nan(x))) {
    return(FALSE)
  } else {
    return(any(x, na.rm = TRUE))
  }
}
deviationLarge<- any_true_except_all_nan( abs(avgSampleRelCtr) > 40 )

if ( deviationLarge ) { #check if deviation from screen center of average fixation location is greater than 40
  msg = paste0("Average eye location should be near screen center (",widthPix/2,",",heightPix/2,") but")
  msg=paste0(msg,"for this participant, it's more than")
  msg=paste(msg,criterionDist,"pixels from the center, on average the eye position relative to center was (x,y)")
  msg=paste0(msg,'(',round(avgSampleRelCtr$x,1),',',round(avgSampleRelCtr$y,1),')')
  msg=paste(msg,"This happens because the eyetracker or its calibration was no good, or the participant didn't look near center much.")
  message(msg)
} else {
  msg="Average eye position was pretty close to screen center, deviated on average: (x,y) "
  msg=paste0(msg,'(',round(avgSampleRelCtr$x,1),',',round(avgSampleRelCtr$y,1),')')
  message(msg)
}

```

Plot average eye position in each quartile of trials

```{r}
#| echo: false

screenResolutions <- data.frame( widthPix = c(800,1024,1512,1600,1600)-widthPix/2, 
                                  heightPix=c(600,768,982,900,1200)-heightPix/2,
                    resolution=c("800x600","1024x768","1512x982","1600x900","1600x1200"))
commonScrnResolutns<- screenResolutions[1:2,]

samples<-samples |> mutate(xDev = x - widthPix/2, yDev = y - heightPix/2)

# Calculate quartiles
quartiles <- quantile(samples$trial)
# Create the new column 'quartile'
samples <- samples %>%
  mutate(quartile = cut(trial, breaks = quartiles, include.lowest = TRUE, labels = FALSE))

avg<- samples |> group_by(quartile) |> 
  summarise(meanX = mean(xDev,na.rm=T), meanY = mean(yDev,na.rm=T))

avgPlot<- ggplot(avg, aes(x= meanX, y= meanY, label=quartile))+  
                          geom_point() +geom_text(hjust=0, vjust=0)
#Add cross at center
avgPlot<-avgPlot +
      geom_point(data=tibble(x=0,y=0),
               aes(x=x,y=x,label=NULL),color="darkred",shape=3) 
#Add title and set graph limits
avgPlot<-avgPlot +  
  ggtitle('Average eye position of each quartile',subtitle=', with red cross showing screen center') +
  xlim(-widthPix/2,widthPix/2) + ylim(-heightPix/2,heightPix/2) +
  theme_bw() + theme( panel.grid.minor=element_blank(),panel.grid.major=element_blank() )

show(avgPlot)
```


For Momo's program downstairs, the first trial doesn't work for some reason, so for her we should throw away the first trial. (If don't want to do that, set to FALSE)

```{r}
throwAwayFirstTrial = TRUE
```


```{r}
#| echo: false

fixatns<- EDFstuff$fixations
if (throwAwayFirstTrial) { #Throw away first trial
  fixatns<- fixatns %>% filter(trial > 1)
}
```

Look at first portion of trial before the targets are highlighted for example, when it doesn't matter where participants are looking but we could use some of that portion for drift correction if we trust the participant.

```{r}
#| echo: false

```

Just look after first 2000ms, because first 800-\>1300ms is fixation, then blobs cued for 1200ms So really I don't have to exclude until after 800+1200=2000ms.

For participants after 1 June, added record of fixatnPeriodFrames, so for them only have to exclude after fixatnPeriodFrames\*refreshRate + 1200.

From previous exploring, I know that lots of occasional bad stuff happens over the first 100ms.

```{r}
#Calculate time by which it matters that they're fixating, which is when targets are no longer cued
fixationInterval = c(800,1300)
trackingExtraTime = 1.2 #seconds, which is how long the blobs are cued, but that's after the fixation interval
trialMinTimeBeforeCuesOff = min(fixationInterval) + trackingExtraTime
#Can also look at additional columns in later versions of the program, that show fixationInterval
```

Plot to see how average fixation x changes over time across trials, after minimum fixation interval, to look for possible drift (gradual trend of calibration getting more and more wrong).

```{r}
#| echo: false

#Plot to see how it changes over time across trials
fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavx = mean(gavx, na.rm = TRUE)) %>%
  ggplot(aes(x = trial, y = gavx)) +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() #You can see the drift

```

Plot to see how average fixation y changes over time across trials, to look possible drift (gradual trend of calibration getting more and more wrong).

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavy = mean(gavy, na.rm = TRUE)) %>%
  ggplot(aes(x = trial, y = gavy)) +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_point() #You can see the drift

```

Look for possible drift (gradual trend of calibration getting more and more wrong) of average fixation position across trials with 2D plot.

```{r}
#| echo: false
fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavx = mean(gavx, na.rm = TRUE), gavy = mean(gavy, na.rm = TRUE)) %>%
  ggplot(aes(x = gavx, y = gavy)) +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_vline(xintercept = widthPix/2,col="black") +  
  geom_point(aes(color=trial))

#ggplot(fixatns, aes(x=gavx, y=gavy, color=trial) ) +
#  stat_summary(fun="mean",geom="point")

#Implement drift correction,
# by taking average of every trial? Need to decide on limited interval at beginning of trial.
```

Look at x and y traces of trials for first 50 trials

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>%
  filter(trial<50) %>% 
  ggplot( aes(x=sttime_rel, y=gavx, color=trial) ) +
  ylab('average x during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('First 50 trials') +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial))

```

Divide trials into four groups (quartiles) and plot for each
```{r}
#| echo: false
# Calculate quartiles
quartiles <- quantile(samples$trial)
# Create the new column 'quartile'
fixatns <- fixatns %>%
  mutate(quartile = cut(trial, breaks = quartiles, include.lowest = TRUE, labels = FALSE))
fixatns<- fixatns |> mutate(trialWithinQuartile = trial-(quartile-1)*max(samples$trial)/max(fixatns$quartile))

fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>% 
  ggplot( aes(x=sttime_rel, y=gavx, color=trialWithinQuartile) ) +
  ylab('average x during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('') +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```
Do it for y

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>% 
  ggplot( aes(x=sttime_rel, y=gavy, color=trialWithinQuartile) ) +
  ylab('average y during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('') +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```

Plot distance from fixation over time. Actually show first period where cues are still always on to see if that is the most reliable time of fixation.

```{r}
#| echo: false
fixatns$distFromFixatn = sqrt( (fixatns$gavx - widthPix/2)^2 + (fixatns$gavy - heightPix/2)^2 )

overTime<- fixatns %>%
  ggplot( aes(x=sttime_rel, y=distFromFixatn, color=trialWithinQuartile) ) +
  geom_point() + geom_line(aes(group=trial)) +
  geom_vline(xintercept=trialMinTimeBeforeCuesOff) +
  ggtitle('Distance from fixation over each trial') + facet_wrap(.~quartile)
show(overTime)
```

The first 300 ms or so look very bad, so exclude that and only show first 1000 ms to further zoom in.

```{r}
#| echo: false
overTime + xlim(350,2000)
```

Zoom in but show outliers in red to indicate they'd be off the scale.

```{r}
#| echo: false

minValToShow = 0
maxValToShow = 50
  
fixatns %>% filter(sttime_rel > trialMinTimeBeforeCuesOff) %>% 
  mutate(outlier = ifelse(distFromFixatn<minValToShow | distFromFixatn>maxValToShow, TRUE, FALSE)) %>%  #determine outliers
  mutate(distFromFixatn =  ifelse(distFromFixatn > maxValToShow, maxValToShow, distFromFixatn)) %>%     #replace outliers
  mutate(distFromFixatn =  ifelse(distFromFixatn < minValToShow, minValToShow, distFromFixatn)) %>%
  ggplot( aes(x=sttime_rel, y=distFromFixatn, color=trialWithinQuartile, shape=outlier) ) +
      ylim(minValToShow,maxValToShow) + #restrict axes
      scale_shape_manual(values = c(16, 21)) + #filled circle and unfilled, for outliers
      geom_point(fill='red') + #only the outlier symbol is fillable
      geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```

## Consider effect of different criteria for excluding trials

Calculate and visualize how many trials will be excluded under various criteria.

Want to have criterion on horizontal axis and proportion trials excluded on vertical axis.

This will require creating a new dataframe because for each trial, need to calculate numCriteria things, meaning the number of rows will expand.
One way to do it would be to do a sort of expand_grid where every trial gets duplicated by numCriteria, with criterion a new column. Then, apply whatever is in the criterion column to each row.

```{r}
#| echo: false

distFromCenterCriteria <- c(20,30,60,100)

```

Calculate whether each trial's distFromFixatn is greater than each criteiron
```{r}
#| echo: false

applyCriteria <- function(distFromFixatn) {
  distFromFixatn > distFromCenterCriteria
}

newColumns<- fixatns %>% rowwise() |>
  reframe( lookedTooFarAway = applyCriteria(distFromFixatn), 
           criterion = distFromCenterCriteria ) 

#Duplicate original dataframe, each row repeat number of criteria times
longer<-fixatns %>% slice(rep(1:n(), each = length(distFromCenterCriteria)))

#Combine the new columns with the old
eachCriterionCheckedEveryFixatn<- cbind(newColumns,longer)

#Currently it checked every fixation in each trial, now need to collapse to have one row per trial*criterion
#anyTooFarAway means any fixation on a trial was too far away
eachCriterionEveryTrial <- eachCriterionCheckedEveryFixatn |>  filter(sttime_rel > trialMinTimeBeforeCuesOff) |>
      group_by(trial,criterion) |>
      summarise(anyTooFarAway = any(lookedTooFarAway), numTooFarAway = sum(lookedTooFarAway))
```

Now calculate proportion of trials anyTooFarAway for each criterion
anyTooFarAway means any fixation on a trial was too far away:

```{r}
#| echo: false
proportnEachCriterion <- eachCriterionEveryTrial |> group_by(criterion) |> 
        summarise( proportnTooFarAway = mean(anyTooFarAway), 
                   avgNumForTrialsTooFarAway = sum(anyTooFarAway[anyTooFarAway]) )
#Also want to calculate average numTooFarAway for each that had a trial too far away

print(round(proportnEachCriterion,3))
```

Visualize proportion of trials too far away for each criterion.

```{r}
#| echo: false

ggplot(proportnEachCriterion, aes(x=criterion,y=proportnTooFarAway)) +
    geom_point() + xlab('criterion (pixels)') +
    ggtitle(fname)
```


Plot by trialnum whether each trial should be excluded, for each criterion.

```{r}
#| echo: false

ggplot(eachCriterionEveryTrial, aes(x=trial,y=anyTooFarAway,group=)) +
    geom_point()  + geom_line() +
    ggtitle(fname) + facet_grid(criterion~.)
```

## Lists of trials

Generate the list of trials to be excluded for a specific criterion

```{r}
myCriterion = 40 #pixels
```

```{r}
#| echo: false

tooFarEachTrial<- fixatns |> filter(sttime_rel > trialMinTimeBeforeCuesOff) |>
        mutate(tooFar = distFromFixatn > myCriterion) |> 
        group_by(trial) |> 
        summarise(anyTooFar = any(tooFar)) 
trialsTooFar <- which(tooFarEachTrial$anyTooFar)
        
```

The trials in which the person had fixatns farther than `r myCriterion` pixels from fixation, fater the initial `r trialMinTimeBeforeCuesOff` seconds before the cues are no longer on, was:

```{r}
#| echo: false
print(trialsTooFar)
```
