---
title: "Examine eyetracking data for an individual participant"
format: html
editor: visual
---

Overall the exampleAnalysesWithGoodFixator report showed that for at least 7 trials out of 120, the eyetracker is way off, with X off by 90 pixels. Otherwise, things were reasonable esp. after first 500 ms when fixation period starts. But by reasonable, I mean that drift or something means that X and Y was off by up to \~20 pixels. For the weird 7 trials, there weren't many fixations so I should check how much missing data ("blinks") there was, maybe that helps explain why those trials were weird.

## Do basic checks

```{r}
#| echo: false
library(eyelinkReader)
library(dplyr)
library(ggplot2)
widthPix = 800; heightPix = 600
```

Read in an EDF file.

```{r}
#| echo: false

directoryWithDataFile<-"dataForTestingOfCode"
fname<-"M471.EDF"
EDFfileWithPath<-file.path(directoryWithDataFile,fname)
if (!file.exists(EDFfileWithPath)) {
  message( paste0("File'",EDFfileWithPath,"'not found!") )
  stop('Could not find the file')
}
EDFstuff <- eyelinkReader::read_edf(EDFfileWithPath,
                                    import_samples = TRUE,
                                    sample_attributes = c('time', 'gx', 'gy'))
```

## Graphs

Assuming screen width is `r widthPix` pixels and screen height is `r heightPix` pixels,

check mean gX in and mean gY in samples (raw eyetracker record of where person was looking) to see where it is relative to screen center.

```{r}
#| echo: false

screenCtr <-  data.frame( x=widthPix/2, y= heightPix/2)
criterionDist<-40
samples<- EDFstuff$samples
avgSampleRelCtr<- samples %>%
                summarise(x = mean(gxR,na.rm=TRUE), y = mean(gyR,na.rm=TRUE)) - screenCtr
                            

if ( any( abs(avgSampleRelCtr) > 40 ) ) { #check if deviation from screen center of average fixation location is greater than 40
  msg = paste0("Average eye location should be near screen center (",widthPix/2,",",heightPix/2,") but")
  msg=paste0(msg,"for this participant, it's more than")
  msg=paste(msg,criterionDist,"pixels from the center, on average the eye position relative to center was (x,y)")
  msg=paste0(msg,'(',round(avgSampleRelCtr$x,1),',',round(avgSampleRelCtr$y,1),')')
  msg=paste(msg,"This happens because the eyetracker or its calibration was no good, or the participant didn't look near center much.")
  message(msg)
} else {
  msg="Average eye position was pretty close to screen center, deviated on average: (x,y) "
  msg=paste0(msg,'(',round(avgSampleRelCtr$x,1),',',round(avgSampleRelCtr$y,1),')')
  message(msg)
}

```

Plot average eye position in each quartile of trials

```{r}
#| echo: false

screenResolutions <- data.frame( widthPix = c(800,1024,1512,1600,1600)-widthPix/2, 
                                  heightPix=c(600,768,982,900,1200)-heightPix/2,
                    resolution=c("800x600","1024x768","1512x982","1600x900","1600x1200"))
commonScrnResolutns<- screenResolutions[1:2,]

samples<-samples |> mutate(xDev = gxR - widthPix/2, yDev = gyR - heightPix/2)

# Calculate quartiles
quartiles <- quantile(samples$trial)
# Create the new column 'quartile'
samples <- samples %>%
  mutate(quartile = cut(trial, breaks = quartiles, include.lowest = TRUE, labels = FALSE))

avg<- samples |> group_by(quartile) |> 
  summarise(meanX = mean(xDev,na.rm=T), meanY = mean(yDev,na.rm=T))

avgPlot<- ggplot(avg, aes(x= meanX, y= meanY, label=quartile))+  
                          geom_point() +geom_text(hjust=0, vjust=0)
#Add cross at center
avgPlot<-avgPlot +
      geom_point(data=tibble(x=0,y=0),
               aes(x=x,y=x,label=NULL),color="darkred",shape=3) 
#Add title and set graph limits
avgPlot<-avgPlot +  
  ggtitle('Average eye position of each quartile',subtitle=', with red cross showing screen center') +
  xlim(-widthPix/2,widthPix/2) + ylim(-heightPix/2,heightPix/2) +
  theme_bw() + theme( panel.grid.minor=element_blank(),panel.grid.major=element_blank() )

show(avgPlot)
```

Just look after first 2000ms, because first 800-\>1300ms is fixation, then blobs cued for 1200ms So really I don't have to exclude until after 800+1200=2000ms.

For participants after 1 June, added record of fixatnPeriodFrames, so for them only have to exclude after fixatnPeriodFrames\*refreshRate + 1200.

From previous exploring, I know that lots of occasional bad stuff happens over the first 100ms.

```{r}
#| echo: false

#Calculate time by which it matters that they're fixating, which is when targets are no longer cued
fixationInterval = c(800,1300)
trackingExtraTime = 1.2 #seconds, which is how long the blobs are cued, but that's after the fixation interval
trialMinTimeCuesOff = min(fixationInterval) + trackingExtraTime
#Can also look at additional columns in later versions of the program, that show fixationInterval
```

Plot to see how average fixation x changes over time across trials, after minimum fixation interval, to look for possible drift (gradual trend of calibration getting more and more wrong).

```{r}
#| echo: false
fixatns<- EDFstuff$fixations

#Plot to see how it changes over time across trials
fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavx = mean(gavx, na.rm = TRUE)) %>%
  ggplot(aes(x = trial, y = gavx)) +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() #You can see the drift

```

Plot to see how average fixation y changes over time across trials, to look possible drift (gradual trend of calibration getting more and more wrong).

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavy = mean(gavy, na.rm = TRUE)) %>%
  ggplot(aes(x = trial, y = gavy)) +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_point() #You can see the drift

```

Look for possible drift (gradual trend of calibration getting more and more wrong) of average fixation position across trials with 2D plot.

```{r}
#| echo: false
fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>%
  group_by(trial) %>%
  summarise(gavx = mean(gavx, na.rm = TRUE), gavy = mean(gavy, na.rm = TRUE)) %>%
  ggplot(aes(x = gavx, y = gavy)) +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_vline(xintercept = widthPix/2,col="black") +  
  geom_point(aes(color=trial))

#ggplot(fixatns, aes(x=gavx, y=gavy, color=trial) ) +
#  stat_summary(fun="mean",geom="point")

#Implement drift correction,
# by taking average of every trial? Need to decide on limited interval at beginning of trial.
```

Look at x and y traces of trials for first 50 trials

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>%
  filter(trial<50) %>% 
  ggplot( aes(x=sttime_rel, y=gavx, color=trial) ) +
  ylab('average x during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('First 50 trials') +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial))

```

Divide trials into four groups (quartile) and plot for each
```{r}
#| echo: false
# Calculate quartiles
quartiles <- quantile(samples$trial)
# Create the new column 'quartile'
fixatns <- fixatns %>%
  mutate(quartile = cut(trial, breaks = quartiles, include.lowest = TRUE, labels = FALSE))
fixatns<- fixatns |> mutate(trialWithinQuartile = trial-(quartile-1)*max(samples$trial)/max(fixatns$quartile))

fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>% 
  ggplot( aes(x=sttime_rel, y=gavx, color=trialWithinQuartile) ) +
  ylab('average x during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('') +
  geom_hline(yintercept = widthPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```
Do it for y

```{r}
#| echo: false

fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>% 
  ggplot( aes(x=sttime_rel, y=gavy, color=trialWithinQuartile) ) +
  ylab('average y during fixation') + xlab('sttime_rel (ms)') +
  ggtitle('') +
  geom_hline(yintercept = heightPix/2,col="black") +  
  geom_point() + geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```

Plot distance from fixation over time

```{r}
#| echo: false
fixatns$distFromFixatn = sqrt( (fixatns$gavx - widthPix/2)^2 + (fixatns$gavy - heightPix/2)^2 )

fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>%
  ggplot( aes(x=sttime_rel, y=distFromFixatn, color=trialWithinQuartile) ) +
  geom_point() + geom_line(aes(group=trial)) +
  ggtitle('Distance from fixation over each trial') + facet_wrap(.~quartile)

```

Zoom in but show outliers off-scale in red.

```{r}
#| echo: false

minValToShow = 0
maxValToShow = 50
  
fixatns %>% filter(sttime_rel > trialMinTimeCuesOff) %>% 
  mutate(outlier = ifelse(distFromFixatn<minValToShow | distFromFixatn>maxValToShow, TRUE, FALSE)) %>%  #determine outliers
  mutate(distFromFixatn =  ifelse(distFromFixatn > maxValToShow, maxValToShow, distFromFixatn)) %>%     #replace outliers
  mutate(distFromFixatn =  ifelse(distFromFixatn < minValToShow, minValToShow, distFromFixatn)) %>%
  ggplot( aes(x=sttime_rel, y=distFromFixatn, color=trialWithinQuartile, shape=outlier) ) +
      ylim(minValToShow,maxValToShow) + #restrict axes
      scale_shape_manual(values = c(16, 21)) + #filled circle and unfilled, for outliers
      geom_point(fill='red') + #only the outlier symbol is fillable
      geom_line(aes(group=trial)) + facet_wrap(.~quartile)
```
Visualize how many trials will be excluded under various criteria.

Want to have criterion on horizontal axis and proportion trials excluded on vertical axis.

This will require creating a new dataframe because for each trial, need to calculate numCriteria things, meaning the number of rows will expand.
One way to do it would be to do a sort of expand_grid where every trial gets duplicated by numCriteria, with criterion a new column. Then, apply whatever is in the criterion column to each row.

```{r}
#| echo: false

distFromCenterCriteria <- seq(20,100,10)

```

```{r}
#| echo: false

applyCriteria <- function(distFromFixatn) {
  distFromFixatn > distFromCenterCriteria
}

fixatns %>% rowwise() |>
  reframe( lookedTooFarAway = applyCriteria(distFromFixatn) ) 

```

```{r}
#| echo: false

applyCriteria <- function(distFromFixatn) {
  xx<<-distFromFixatn
  distFromFixatn > distFromCenterCriteria[0]
}

fixatns %>% rowwise() |>
  reframe( lookedTooFarAway = applyCriteria(distFromFixatn) ) 

```

```{r}
#| echo: false

applyCriteria <- function(n) {
  n>1
}

tibble(n = 2:0) %>% rowwise |>
  reframe(out = applyCriteria(n))

tibble(n = 2:0) %>% 
  rowwise() %>% 
  reframe(out = applyCriteria(n))

```

```{r}
#| echo: false

applyCriteria <- function(n) {
  rep(n, n)
}

tibble(n = 2:0) %>% 
  group_by(n) %>% 
  reframe(out = applyCriteria(n))

```
