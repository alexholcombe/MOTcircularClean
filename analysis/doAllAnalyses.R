#This file analyses anonymized data provided by "loadAnonymiseSaveData.R" in exp-specific directory
#These are not the ones appropriate for looking at tf limits, which are in "speed-tf-VSS14" folder with separate analysis file
#Working directory is set hopefully by Rproj file to directory that it's in.
setwd(
"/Users/alexh/Documents/attention_tempresltn/multiple object tracking/newTraj/newTraj_repo/analysis"
)
####################analyse offCenterAndShape ################

dataDir="../dataAnonymized/"
expName="offCenterAndShape"
anonDataFilename = paste(dataDir,expName,".Rdata",sep="") #generated by loadAnonymiseSaveData.R
load(anonDataFilename,verbose=TRUE)  #returns dat
excludeFixationViolations = TRUE; proportnTrialsMustFixate = .6
excludeDidntReach75pct = TRUE
useQuickpsy = TRUE
if (useQuickpsy) {
  library(devtools) #So can load from Alex's local quickpsy package repository
  #install_github('danilinares/quickpsy')
  load_all("/Users/alexh/Documents/softwareStatsEquipment/programming_psychophysics/quickpsy/quickpsy")
  #library('quickpsy')
}
datWithFixatnViolatns = dat #save for possible future use
if (excludeFixationViolations) {
  bySubjExp <- dat %>% group_by(subject,exp)
  pOutCentralArea <- summarise(bySubjExp, pOut = 
                       mean(outOfCentralArea, na.rm = FALSE))
  subjectsToExclude <- filter( pOutCentralArea, pOut>(1-proportnTrialsMustFixate) )
  if (nrow(subjectsToExclude) > 0) {
    subjectsToExclude<- subjectsToExclude$subject
    cat("Excluding Ss for fixatn failure in >",100*(1-proportnTrialsMustFixate),
              "% of trials:",subjectsToExclude,'.\n',sep=' ')
    dat<- filter(dat, !(subject %in% subjectsToExclude))
  } else { 
    cat("No participants excluded for breaking fixatn in >",100*(1-proportnTrialsMustFixate),"% of trials\n",sep='')
  }
  
  datFixatnGood<- subset(dat,dat$outOfCentralArea==0)
  eyeMovementsUnknown<- subset(datWithFixatnViolatns, is.na(datWithFixatnViolatns$outOfCentralArea))
  #datNoFixatnViolatn<- dat[,dat$outOfCentralArea==0  &  !is.na(dat$outOfCentralArea)]
  cat("Excluded for not having eyetracking data:",unique(eyeMovementsUnknown$subject),".")
  pctExcludedBrokeFixatn<-round((1-nrow(datFixatnGood) / 
                                (nrow(datWithFixatnViolatns)-nrow(eyeMovementsUnknown)))*100)
  pctExcludedNoEyemoveData<-round(100*nrow(eyeMovementsUnknown)/nrow(datWithFixatnViolatns))
  cat(" Of remainder, further ",pctExcludedBrokeFixatn,"% excluded for breaking fixation.",sep='')
  dat<-datFixatnGood

}
iv= 'speed'
#need to translate offsetXYeachRing to verbal condName label
assignCondName <- function(df) {
  df$condName='nothing'
  whichSquareExp = df$exp=='circleOrSquare_twoTargets'
  df$condName[ whichSquareExp ] = df$basicShape[whichSquareExp]
  df$condName[ df$offsetXYring0=='[-10, 0]' ] = "far"
  df$condName[ df$offsetXYring0=='[10, 0]' ] = "far"
  df$condName[ df$offsetXYring0=='[-5, 0]' ] = "near"
  df$condName[ df$offsetXYring0=='[5, 0]' ] = "near"
  df$condName[ df$offsetXYring0=='[0, 0]' ] = "centered"
  df$condName[ df$offsetXYring0=='[0, 0]' ] = "centered"
  return (df)
}
dat<-assignCondName(dat)
table(dat$exp,dat$condName)
factorsEachExpForBreakdown<- list(  list(colorF='condName',colF='subject',rowF='leftOrRight'),
                                    list(colorF='condName',colF='subject',rowF='ringToQuery') )

####################analyse circleOrSquare_twoTargets ################
expThis= "circleOrSquare_twoTargets" # "offCenter"
#how specific to break down the data before fitting
factorsForBreakdownForAnalysis <- factorsEachExpForBreakdown[[2]]
#print proportion trials excluded each condition
if (!excludeFixationViolations) {
  cat("Proportion trials where each broke fixation; NOT excluding these")
  print( dplyr::summarise(group_by(dat,subject,condName),pctExcluded=mean(outOfCentralArea)) )
}
if (excludeDidntReach75pct) {
  #is there any subject who did not reach 75% for any condition? at any speed
  subjCondSpeed<- dplyr::summarise(group_by(dat, subject,condName, speed),
            correct=mean(correct))
  #determine max %corr for each subj-condition
  maxSubjCond<- dplyr::summarise(group_by(subjCondSpeed,subject,condName),
                          max=max(correct))
  badSs<- dplyr::filter(maxSubjCond, max<.75)
  badSs<- unique(badSs$subject)
  cat("Excluded for not reaching 75% in one or both conditions:",badSs)
  dat<- dplyr::filter(dat,!(subject %in% badSs))
} 
datThis<-subset(dat,exp==expThis)
datAnalyze<-datThis
#factorsForBreakdownForAnalysis[ length(factorsForBreakdownForAnalysis)+1 ]<- "exp"
if (!useQuickpsy) {
  source('analyzeMakeReadyForPlot.R') #returns fitParms, psychometrics, and function calcPctCorrThisSpeed
  source('individDataWithPsychometricCurves.R') #for plotIndividDataAndCurves()
  plotIndividDataAndCurves(expThis,datThis,psychometrics,factorsForBreakdownForAnalysis,xmin=1,xmax=2.5)
}
if (useQuickpsy) {
  datDani<-datThis  # datDani$speed = -1*datDani$speed
  tit<- paste0(expThis,"vanilla")
  #Create decreasing function to fit
  negCumNormal<-function(x,p) { cum_normal_fun(-x,p) }
  fitCondSubj <- quickpsy(datThis, speed, correct, grouping=.(condName,subject), 
                  bootstrap='none', xmin=.5, xmax=2.2,
                  fun=negCumNormal, guess=0.5, parini = c(1.5,10))
  plot1 <- plotcurves(fitCondSubj) + theme_bw()
  quartz(tit); show(plot1)

  #test whether can fit data broken down all the way including ringToQuery
  tit<-paste(expThis,"including ringQuery")
  result = tryCatch({ 
    calcThreshes = TRUE
    fit <- quickpsy(datThis, speed, correct, grouping=.(condName,subject,ringToQuery), 
                  bootstrap='none', xmin=.5, xmax=2.2, thresholds=calcThreshes,
                  fun=negCumNormal, guess=0.5, parini = c(1.5,10))
  }, error = function(e) {
    msg="Not enough data from first-years to always get non-flat curve for ringToQuery 0 and 1"
    cat(msg,"\n")
    tit <- paste0(expThis,msg)
    calcThreshes = FALSE #dont try to fit curves
    fit <- quickpsy(datThis, speed, correct, grouping=.(condName,subject,ringToQuery), 
                    bootstrap='none', xmin=.5, xmax=2.2, thresholds=calcThreshes,
                    fun=negCumNormal, guess=0.5, parini = c(1.5,10))  
  })
  plot1 <- plotcurves(fit) + theme_bw()
  quartz(tit); show(plot1)
  
  #because ringToQuery is not relevant, don't publish this graph
  tit<- paste0(expThis,"NotToPublish_ThreshesIncludingRingToQuery")
  quartz(title=tit,width=4.3,height=3.7) #create graph of thresholds
  g=ggplot(fit$thresholds, 
           aes(x=factor(condName), y=thre))   + theme_bw()
  dodgeAmt=.4
  g<-g+stat_summary(fun.data="mean_cl_boot",geom="errorbar",width=.3,conf.int=.95,
                    width=5,size=1) 
  g<-g+geom_point(  aes(x=factor(condName), y=thre, 
                        shape=factor(subject), color=factor(ringToQuery)), 
                    position=position_dodge(dodgeAmt), size =2.9   )
  g<-g+geom_line(aes(group=interaction(subject,factor(ringToQuery))),
                 position=position_dodge(width=dodgeAmt))
  show(g)
  ggsave( paste('figs/',tit,'.png',sep='') )
  
  #threshes plot to publish
  tit<- paste0(expThis,"_threshes")
  quartz(title=tit,width=4.3,height=3.7) #create graph of thresholds
  g=ggplot(fit$thresholds, 
           aes(x=condName, y=thre))   + theme_bw()
  dodgeAmt=.4
  g<-g+stat_summary(fun.data="mean_cl_boot",geom="errorbar",conf.int=.95,
                    width=.4,size=1)
  g<-g+stat_summary(fun.y=mean,geom="point",size=3) #confidence interval point at centre
  g<-g+stat_summary(fun.y=mean, geom="point",aes(color=factor(subject)),
                        position=position_dodge(dodgeAmt))
  ylims<-c(0.5,2.2)
  ylimsCurr <- ggplot_build(g)$panel$ranges[[1]]$y.range 
  if ((ylims[1] < ylimsCurr[1]) & (ylims[2] > ylimsCurr[2])) {
    g<-g+ coord_cartesian( ylim=ylims)
  }
  g<-g+xlab("condition")+ylab("threshold") #prettify
  g<-g+labs(color="subject") #prettify
  #g<-g+geom_line(aes(color=factor(subject)))
  #g<-g+geom_line(aes(group=subject))
  #g<-g+geom_line(aes(group=interaction(subject,factor(ringToQuery))),
  #               position=position_dodge(width=dodgeAmt))
  show(g)
  ggsave( paste('figs/',tit,'.png',sep='') )
}
if (!useQuickpsy) {
source("extractThreshesAndPlot.R") #provides threshes, thresh plots
}
#Compare thresholds.
#quickpsy stuff require thresholds be bootstrapped
#thresholdcomparisons(fit)
#fit <- quickpsy(datThis, speed, correct, grouping=.(condName,subject), 
#                bootstrap='parametric', xmin=.5, xmax=2.2,
#                fun=negCumNormal, guess=0.5, parini = c(1.5,10))
#one_thresholdcomparisons(fit$thresholdsbootstrap, fit$thresholds, "condName", ci=.95)

circleThreshes=fitCondSubj$thresholds %>% filter(condName=="circle")
diamondThreshes=fitCondSubj$thresholds %>% filter(condName=="diamond")
t<- t.test(circleThreshes$thre,diamondThreshes$thre,paired=TRUE)
paste0("Mean circleThresh=",round(mean(circleThreshes$thre),1),
      " diamond=",round(mean(diamondThreshes$thre),1),
      ", t(",t$parameter["df"],")=",round(t$statistic,3),", p=",round(t$p.value,3))

####################analyse offCenter #######################################
expThis= "offCenter"
factorsForBreakdownForAnalysis <- factorsEachExpForBreakdown[[1]]
datThis<-subset(dat,exp==expThis)
datThis$subject<- as.factor(datThis$subject)
#Change the ordering of the Ss so the expert ones listed first, because they participated
#in an additional condition.
#datThis$subject <- reorder(datThis$subject, c(2,5,3,1,4,6)) #why doesn't this work?
datThis$subject<- factor(datThis$subject, levels=levels(datThis$subject)[c(2,5,3,1,4,6)])

if (!useQuickpsy) {
  source('analyzeMakeReadyForPlot.R') #returns fitParms, psychometrics, and function calcPctCorrThisSpeed
  source('individDataWithPsychometricCurves.R') #for plotIndividDataAndCurves()
  plotIndividDataAndCurves(expThis,datThis,psychometrics,factorsForBreakdownForAnalysis,xmin=1,xmax=2.5)
}
if (useQuickpsy) {
  #datDani<-datThis; datDani$speed = -1*datDani$speed
  #Create decreasing function to fit
  negCumNormal<-function(x,p) { cum_normal_fun(-x,p) }
  fit <- quickpsy(datThis, speed, correct, grouping=.(condName,subject,leftOrRight),
                  xmin=.8, xmax=2.6,
                  fun=negCumNormal, guess=0.5, parini = c(1.5,10),
                  bootstrap='none')
  #Problems: participant XA has a flat function for one left condition, LO is too good.
  plotDodged<-function(fit) {
    p<-ggplot()  +
      geom_point(data = fit$averages, aes(x = speed, y = y, color = condName), 
                 position=position_dodge(width=.15)) 
    p<-p+ geom_line(data = fit$curves, 
                  aes(x = x, y = y, color = condName))
    #fit$thresholds[[color]] <- factor(fit$thresholds[[color]])
    colorForThreshes <- fit$groups[[1]]
    # get present axis limits
    axisYrange <- ggplot_build(p)$panel$ranges[[1]]$y.range
    p <- p + geom_linerange(data = fit$thresholds,
                            aes_string(x = 'thre', 
                                       ymin = axisYrange[1] - .2, #make sure extends below axis line
                                       ymax = fit$thresholds$prob, color = colorForThreshes))
    #Because threshline extended below axis limit, axis automatically scaled below it.
    #Restore it to its former values
    p <- p + coord_cartesian(ylim=axisYrange)
    return (p)
  }
 plot1=plotDodged(fit)+theme_bw() +facet_grid(leftOrRight~subject)
 quartz(title="breakDownByLeftOrRight_notForPublication",expThis); show(plot1)
 #find my code from last paper for plotting threshes?
 #plotthresholds(fit,color=condName)
 offCtrLeftRightThreshes = fit$thresholds
}
#LO's threshold for centered could not be estimated, he's too fast. 
#But point is if anything, people better for centered than for other conditions.
#Compare percent correct for left versus right
notCentered<- filter(datThis,condName!="centered") #centered condition doesnt have left vs right
leftRightSubj<-dplyr::summarise(group_by(notCentered, subject,leftOrRight),
                 corr=mean(correct))
left<- filter(leftRightSubj,leftOrRight==0)$corr
right<- filter(leftRightSubj,leftOrRight==1)$corr
t<- t.test(left,right,paired=TRUE)
#No sig advantage of left or right side, so collapse but need ANOVA test to justify
paste0("Mean left=",round(mean(left),2),
       " right=",round(mean(right),2),
       ", t(",t$parameter["df"],")=",round(t$statistic,3),", p=",round(t$p.value,3))
ANOVA
#Dont break down by left or right this time
tit<- paste0(expThis,"_psychometrics")
quartz(title=tit,width=7,height=3.) #create graph of thresholds, left vs. Right
fit <- quickpsy(datThis, speed, correct, grouping=.(condName,subject),
                xmin=.8, xmax=2.6,
                fun=negCumNormal, guess=0.5, parini = c(1.5,10),
                bootstrap='none')
offCtrThreshes <- fit$thresholds
plot2=plotDodged(fit)+theme_bw() +facet_grid(.~subject)
plot2$labels$colour<-"condition" #http://stackoverflow.com/questions/14622421/how-to-change-legend-title-in-ggplot-density#
plot2<-plot2+ylab('correct')
show(plot2)
ggsave( paste('figs/',tit,'.png',sep='') )

tit<-paste0(expThis,"_threshes")
quartz(title=tit,width=4.3,height=3.7) #create graph of thresholds
g=ggplot(offCtrThreshes, aes(x=factor(condName), y=thre, color=subject,shape=subject))   + theme_bw()
dodgeAmt=.25
g<-g+stat_summary(fun.data="mean_cl_boot",geom="errorbar",width=.3,conf.int=.95,
                  width=5,size=1,position=position_dodge(width=dodgeAmt)) 
g<-g+geom_point( position=position_dodge(dodgeAmt), size =2.9   )
g<-g+geom_line(aes(group=subject),position=position_dodge(dodgeAmt))
g<-g+ylab("threshold (rps)")
show(g)
ggsave( paste('figs/',tit,'.png',sep='') )
#Stats COMPARE CENTRED TO FAR
noPat<- filter(offCtrThreshes,subject!="LO")
centeredNoPat<- filter(noPat,condName=="centered")$thre
farNoPat<- filter(noPat,condName=="far")$thre
t<- t.test(centeredNoPat,farNoPat,paired=TRUE)
#No sig diff between centered and far
paste0("Mean centered=",round(mean(centeredNoPat),2),
       " far=",round(mean(farNoPat),2),
       ", t(",t$parameter["df"],")=",round(t$statistic,3),", p=",round(t$p.value,3))
ratioPredictn<-1.82 #Receptive fields theory predicts 82% faster for far condition
ratioObs<- farNoPat/centeredNoPat
t<-t.test(ratioObs,mu=ratioPredictn)
paste0("Observed ratio=",round(mean(ratioObs),2),
       " comparing to ",round(mean(ratioPredictn),2),
       ", t(",t$parameter["df"],")=",round(t$statistic,3),", p=",round(t$p.value,3))
#Also should do Bayesian test because have both null (ratio=1) and alternative (1.82) hypothesis
#Sent a tweet to Daniel Lakens asking whether his thing does a one-sample (z) test
#COMPARE CENTRED TO NEAR
nearNoPat<- filter(noPat,condName=="near")
#get list of participatns who did near, get their centered threshold
centeredAlsoTestedOnNear<- subset(noPat, subject %in% unique(nearNoPat)$subject)
centeredAlsoTestedOnNear<- filter(centeredAlsoTestedOnNear, condName=="centered")$thre
nearNoPat<- nearNoPat$thre
#No sig diff between centered and near
t<- t.test(centeredAlsoTestedOnNear,nearNoPat,paired=TRUE)
paste0("Among the ",length(nearNoPat)," besides LO tested on near, mean centered=",
        round(mean(centeredAlsoTestedOnNear),2),
       " near=",round(mean(nearNoPat),2),
       ", t(",t$parameter["df"],")=",round(t$statistic,3),", p=",round(t$p.value,3))

#Do stats to disprove the absurd theory


#CRT_spinzter experiment#######################################################################
load( paste0(dataDir,"E2_CRT_spinzter.RData"),verbose=TRUE) #E2
E2<-dat
#For CRT data, I need to take mean across trials. Spinzter already is
meanThreshold<-function(df) {
  thresh<-mean(df$thresh)
  df= data.frame(thresh)
  return(df)
}
factorsPlusSubject=c("numObjects","subject","direction","ecc","device")
E2threshes<- ddply(E2, factorsPlusSubject,meanThreshold) #average over trialnum,startSpeed
#plot
tit<-"E2threshesSpeed"
quartz(title=tit,width=2.8,height=3.1) #create graph of thresholds
E2threshes$eccentricity<- as.factor(E2threshes$ecc)
#reorder device so that legend aligns with height of data points
E2threshes$device <- factor(E2threshes$device, levels = unique(E2threshes$device)[2:1])
g=ggplot(E2threshes, aes(x=numObjects, y=thresh, fill=device, shape=eccentricity))
dodgeAmt=0.35
SEerrorbar<-function(x){ SEM <- sd(x) / (sqrt(length(x))); data.frame( y=mean(x), ymin=mean(x)-SEM, ymax=mean(x)+SEM ) }
g<-g+ stat_summary(fun.data="SEerrorbar",geom="point",size=2.5,position=position_dodge(width=dodgeAmt))
g<-g+scale_fill_manual(values=c("black","white"))+scale_shape_manual(values=c(21,22))
g<-g+ guides(fill = guide_legend(override.aes = list(shape = c(21,21)))) #http://stackoverflow.com/questions/12488905/why-wont-the-ggplot2-legend-combine-manual-fill-and-scale-values
g<-g+ guides(shape = guide_legend(override.aes = list(fill = c("grey")))) #http://stackoverflow.com/questions/12488905/why-wont-the-ggplot2-legend-combine-manual-fill-and-scale-values
g<-g + xlab('objects')+ylab('threshold (rps)')
#g<-g+ stat_summary(fun.y=mean,geom="point",size=2.5,position=position_dodge(width=dodgeAmt))
g<-g+stat_summary(fun.data="SEerrorbar",geom="errorbar",width=.25,position=position_dodge(width=dodgeAmt))
g=g+theme_bw() #+ facet_wrap(~direction)
g<-g+theme(panel.grid.minor=element_blank(),panel.grid.major=element_blank())# hide all gridlines.
g<-g+ coord_cartesian( ylim=c(1.25,2.53), xlim=c(1.6,3.4))
g<-g+ scale_x_continuous(breaks=c(2,3))
g<-g+ scale_y_continuous(breaks=c(1.5,2,2.5))
g<-g+ theme(axis.title.y=element_text(vjust=0.66))
g<-g+theme(axis.ticks.margin=unit(.03,'cm')) #Move tick labels closer to axis
g<-g+theme(legend.key = element_blank()) #remove internal lines in legend
show(g)
ggsave( paste('figs/',tit,'.png',sep='') )

#source ( model limits) ??
#source analyseSlopes?

