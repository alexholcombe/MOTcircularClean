#This file analyses anonymized data provided by "loadAnonymiseSaveData.R" in exp-specific directory
#This script expects the working directory to be "newTraj_repo/analysis"
library(readr)

dataDir<- file.path("..","dataAnonymized")
expName<- "youngOld"
#anonDataFileR<- paste0(expName,".Rdata") #generated by loadAnonymiseSaveData.R in dataPreprocess directory
anonDataFile<- paste0(expName,".tsv") #generated by loadAnonymiseSaveData.R in dataPreprocess directory

dat<- readr::read_tsv( file.path(dataDir,expName,anonDataFile),  show_col_types=FALSE)
  
#load( file.path(dataDir,expName,anonDataFileR), verbose=TRUE)  #returns rawData

excludeFixationViolations = TRUE; proportnTrialsMustFixate = .6
excludeDidntReach75pct = TRUE

#table(d$speedRank,d$numObjects,d$numTargets,d$subject)

#check data counterbalancing of this exp
source("analysis/helpers/checkCounterbalancing.R")
checkCombosOccurEqually(rawData, c("numObjects","numTargets") )
checkCombosOccurEqually(rawData, c("numObjects","numTargets","ringToQuery") )
checkCombosOccurEqually(rawData, c("condition","leftOrRight") )
checkCombosOccurEqually(rawData, c("condition","leftOrRight","offsetXYring0") ) #NO?
checkCombosOccurEqually(rawData, c("numObjects","numTargets","speed") )  
}

dat <-rawData
#end data importation

#Also need to get age and sex from somewhere.. a manual copy of the Sharepoint participant sheet with only those columns?

#Eyemovement exclusion zone numbers
exclusionDeg = 1 #in any direction from fixation
widthPix = 800
heightPix = 600
monitorWidth = 39.5 #cm
viewdist = 57 #cm
widthScreenDeg =  2*(atan((monitorWidth/2)/viewdist) /pi*180)
pixelsPerDegree = widthPix / widthScreenDeg
exclusionPixels = exclusionDeg * pixelsPerDegree
centralZoneWidthPix = exclusionPixels*2
centralZoneHeightPix = exclusionPixels*2 #assumes the monitor is correct aspect ratio so that pixels are square


#If instead of using raw speed, I rank the speed within each numObjects*numTargets, then from that perspective everything should
#be perfectly counterbalanced, because each numObjects*numTargets combination has the same number of speeds tested
#But the rank for a speed depends on what numObjects-numTargets condition it's in. Should be easy with ddply
ordinalSpeedAssign <- function(df) {
  #df$speedRank <- rank(df$speed)  #Rank won't work, always wants to break all ties. Whereas I want to preserve ties.
  df$speedRank <- match(df$speed,unique(df$speed))
  df
}
d<- plyr::ddply(dat,.(numObjects,numTargets),ordinalSpeedAssign)
#grouped<- group_by(dat,numObjects,numTargets) #can't get this to work with dpylr but involves something with .  http://stackoverflow.com/questions/22182442/dplyr-how-to-apply-do-on-result-of-group-by
#d<- dplyr::summarise(grouped, speedRank= match(speed,unique(.$speed)))
#dat %>% group_by(numObjects,numTargets) %>% do(match(speed,unique(.$speed)))
#check whether counterbalanced with for each speed list for a particular condition, did each equally often
#Might not be if ran multiple sessions with different speeds
checkCombosOccurEqually(d, c("numObjects","numTargets","speedRank") )

sanityCheckEyeTracking=TRUE
if (sanityCheckEyeTracking) {
  library(ggplot2)
  h<-ggplot(filter(dat,exp=="circleOrSquare_twoTargets"),
            aes(x=maxXdev,y=maxYdev,color=file)) + geom_point() +facet_grid(~subject)  #Have a look at fixation positions
  quartz("circleOrSquare_twoTargets"); show(h)
  h<-ggplot(filter(dat,exp=="offCenter"),
            aes(x=maxXdev)) + geom_histogram()+ facet_grid(~subject) #Have a look at fixation positions
  quartz("offCenter"); show(h)
}
dat$correct = dat$orderCorrect /3
dat$chanceRate= 1 / dat$numObjects

